// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define THREAD_GROUP_SIZE 128
#define SOFTENING_FACTOR 0.015
#define EPSILON 1e-5

struct Particle 
{
    float4 positionMass; // xyz pos, w mass
    float3 velocity;
    float4 color;
};

// main data buffer
RWStructuredBuffer<Particle> _ParticleBuffer;

float _Time;
float _DeltaTime; 
float _GravityStrength;
float _MaxColorSpeed;
float _ParticleCount;

groupshared Particle _SharedParticles[THREAD_GROUP_SIZE];

float3 CalculateForce(float4 cm1, float4 cm2)
{
    float3 directionVector = cm2.xyz - cm1.xyz;
    float distSqr = dot(directionVector, directionVector) + EPSILON;

    if (distSqr < SOFTENING_FACTOR * SOFTENING_FACTOR) return float3(0.0, 0.0, 0.0);

    float inverseDist = rsqrt(distSqr);
    float invDistCube = inverseDist * inverseDist * inverseDist;
    
    // F = G * m_particle * m_node * r / (dist^3)
    return _GravityStrength * cm1.w * cm2.w * directionVector * invDistCube;
};

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 local_id : SV_GroupThreadID)
{
    Particle p = _ParticleBuffer[id.x];

    float3 totalForce = float3(0.0, 0.0, 0.0);
    
    uint tileCount = (uint)_ParticleCount / THREAD_GROUP_SIZE;
    if (_ParticleCount % THREAD_GROUP_SIZE != 0)
    {
        tileCount += 1;
    }
    
    for (uint tile = 0; tile < tileCount; tile++)
    {
        uint tile_index = tile * THREAD_GROUP_SIZE + local_id.x;
        if (tile_index < _ParticleCount)
        {
            _SharedParticles[local_id.x] = _ParticleBuffer[tile_index];
        }
        else
        {
            // if particle count is not divisible by 64, load a dummy particle
            _SharedParticles[local_id.x].positionMass.w = 0.0;
            _SharedParticles[local_id.x].positionMass = float4(0,0,0,0);
        }

        // wait for all threads to finish loading
        GroupMemoryBarrierWithGroupSync();

        // only calculate against shared memory
        for (uint i = 0; i < THREAD_GROUP_SIZE; i++)
        {
            Particle target = _SharedParticles[i];
            if (target.positionMass.w == 0.0) continue;

            totalForce += CalculateForce(p.positionMass, target.positionMass);
        }
        
        // wait again
        GroupMemoryBarrierWithGroupSync();
    }
    
    float3 acceleration = totalForce / p.positionMass.w;
    p.velocity += acceleration * _DeltaTime;
    p.positionMass.xyz += p.velocity * _DeltaTime;

    float4 hotColor = float4(1.0, 0.8, 0.2, 1.0); // yellow
    float4 coolColor = float4(0.8, 0.1, 0.0, 1.0); // red

    float speed = length(p.velocity);
    float t = saturate(speed / _MaxColorSpeed);
    p.color = lerp(coolColor, hotColor, t);

    // update particle
    _ParticleBuffer[id.x] = p;
}